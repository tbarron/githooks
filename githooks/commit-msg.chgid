#!/usr/bin/env python
"""
git hook for adding version and gerrit Change-Id to commit message

!@! conform to just inserting Change-Id:

This git hooks assumes that the current package's version is defined in a file
named version.py somewhere in the tree with a single line of the form

   __version__ = '<version-string>'

To use this hook, if your git repository is at $GIT,

   mkdir $GIT/githooks
   cp from/somewhere/commit-msg $GIT/githooks
   rm -f .git/hooks/commit-msg
   ln -s $GIT/githooks/commit-msg .git/hooks/commit-msg

"""
import ghlib
import optparse
import os
import pdb
import shlex
import StringIO
import subprocess
import sys


# -----------------------------------------------------------------------------
def main(args):
    """
    Entry point
    """
    p = optparse.OptionParser()
    p.add_option('-d', '--debug',
                 action='store_true', default=False, dest='debug',
                 help='run the debugger')
    (o, a) = p.parse_args(args)
    if o.debug:
        pdb.set_trace()

    filename = a[1]

    msg = ghlib.contents(filename)
    (payload, version, cid, comments) = split_msg(msg)

    if cid.replace('Change-Id:', '').strip() == '':
        cid = get_change_id(msg)

    newname = save_new(filename, payload, version, cid, comments)
    os.rename(filename, filename + ".old")
    os.rename(newname, filename)


# -----------------------------------------------------------------------------
# def catch_stdout(cmd, input=None):
#     """
#     Run *cmd*, optionally passing string *input* to it on stdin, and return
#     what the process writes to stdout
#     """
#     p = subprocess.Popen(shlex.split(cmd),
#                          stdin=subprocess.PIPE,
#                          stdout=subprocess.PIPE,
#                          stderr=subprocess.PIPE)
#     if input:
#         p.stdin.write(input)
#     (o, e) = p.communicate()
#     if p.returncode == 0:
#         return o
#     else:
#         return ''


# -----------------------------------------------------------------------------
# def contents(filename):
#     """
#     Read a file and return its contents
#     """
#     f = open(filename, 'rU')
#     rval = [z.rstrip('\n') for z in f.readlines()]
#     f.close()
#     return rval


# -----------------------------------------------------------------------------
def get_change_id(msg):
    """
    Generate a change id line based on the commit message and return it
    """
    istr = 'tree '
    istr += ghlib.catch_stdout('git write-tree')
    parent = ghlib.catch_stdout('git rev-parse "HEAD^0"')
    if not parent.startswith('ERR:'):
        istr += 'parent ' + parent
    istr += 'author ' + ghlib.catch_stdout('git var GIT_AUTHOR_IDENT')
    istr += 'committer ' + ghlib.catch_stdout('git var GIT_COMMITTER_IDENT')
    istr += '\n'.join(msg)
    rval = ghlib.catch_stdout('git hash-object -t commit --stdin',
                        input=istr)
    return 'Change-Id: I' + rval


# -----------------------------------------------------------------------------
# def get_version():
#     """
#     Scan the current git repo for a file named 'version.py'. We assume it
#     contains a statement that sets __version__ and we use that to construct and
#     return a line of the form 'Version:    x.x.x'
#     """
#     groot = catch_stdout('git rev-parse --show-toplevel')
#     for r, d, f in os.walk(groot.strip()):
#         if 'version.py' in f:
#             vpath = os.path.join(r, 'version.py')
#             break
#     vinfo = contents(vpath)
#     eval(compile('\n'.join(vinfo), vpath, 'exec'))
#     rval = "Version:   %s" % locals()["__version__"]
#     return rval


# -----------------------------------------------------------------------------
def save_new(filename, payload, version, cid, comments):
    """
    Write *payload*, *version*, *cid*, and *comments* to *filename*.new,
    returning the new name
    """
    newname = filename + ".new"
    o = open(newname, 'w')
    o.writelines([p + '\n' for p in payload])
    if 0 < len(payload[-1]):
        o.write("\n")
    o.writelines([cid.strip() + '\n'])
    o.writelines([p + '\n' for p in comments])
    o.close()
    return newname


# -----------------------------------------------------------------------------
def split_msg(msg):
    """
    Scan *msg* and split it into payload, version line, change id line, and
    comments and return those components
    """
    payload = []
    comments = []
    version = ''
    cid = ''
    for l in msg:
        if l.startswith('#'):
            comments.append(l)
        elif 'Version:' in l:
            version = l
            # if l.strip().replace('Version:', '') == '':
            #     version = ''
            # else:
            #     version = l
        elif 'Change-Id:' in l:
            cid = l
            # if l.strip().replace('Change-Id:', '') == '':
            #     cid = ''
            # else:
            #     cid = l
        else:
            payload.append(l)
    return(payload, version, cid, comments)


# -----------------------------------------------------------------------------
if __name__ == '__main__':
    main(sys.argv)
